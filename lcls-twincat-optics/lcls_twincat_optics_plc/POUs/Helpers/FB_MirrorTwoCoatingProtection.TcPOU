<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_MirrorTwoCoatingProtection" Id="{e481ed92-d77f-4692-a2ea-e5f1d2863716}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MirrorTwoCoatingProtection
VAR_INPUT
    nCurrentEncoderCount : UDINT; // Current encoder count
    neVRange : DWORD; // Current ev range from stCurrentBeamParams

    sDevName : STRING := ''; // Device name

    nUpperCoatingBoundary : UDINT; // Encoder count for upper boundary

    sUpperCoatingType : STRING := ''; // Type of coating

    nLowerCoatingBoundary : UDINT; // Encoder count for lower boundary

    sLowerCoatingType : STRING := ''; // Type of coating

    bAutoClear : BOOL := TRUE; // Auto-clear these fast faults

    bRefreshCoatingBPs : BOOL; // Trigger a re-read of the JSON Beam Parameters

END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
    FFO : FB_HardwareFFOutput;
END_VAR
VAR
    ffUpperCoating: FB_FastFault := (
        i_xAutoReset := FALSE,
        i_TypeCode := 16#401);
    ffLowerCoating : FB_FastFault := (
        i_xAutoReset := FALSE,
        i_TypeCode := 16#401);
    sFFBeamParamMismatch : STRING := ' mirror coating incompatible with beam photon energy';
    sFFBeamParamNotLoaded : STRING := ' mirror coating beam parameters not loaded';
    nRefreshAttempts : INT := 0;

    aDbStateParams : ARRAY[0..1] OF ST_DbStateParams;
    fbGetCoatingBPs : FB_JsonDocToSafeBP;

    bExecute : BOOL;
    nJSONLoaded : UXINT := 16#00;

    nUpperCoatingBitmask : DWORD := 0;
    nLowerCoatingBitMask : DWORD := 0;
    i : INT;
    sDevState : STRING  := '';
    bInit : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF PMPS_GVL.BP_jsonDoc > nJSONLoaded and NOT bInit THEN
    ffUpperCoating.i_DevName := sDevName;
    ffLowerCoating.i_DevName := sDevName;

    FOR i:=0 to 1 BY 1 DO
        sDevState := CONCAT(sDevState, sDevName);
        sDevState := CONCAT(sDevState, '-');
        CASE i OF
        0:
            sDevState := CONCAT(sDevState, sUpperCoatingType);
        1:
            sDevState := CONCAT(sDevState, sLowerCoatingType);
        END_CASE
        aDbStateParams[i].sPmpsState := sDevState;
        sDevState := '';
    END_FOR

    bInit := TRUE;
    bExecute := TRUE;
ELSIF PMPS_GVL.BP_jsonDoc > nJSONLoaded and bRefreshCoatingBPs THEN
    bExecute := TRUE;
    nRefreshAttempts := nRefreshAttempts + 1;
END_IF

fbGetCoatingBPs(bExecute := bExecute,
    jsonDoc := PMPS_GVL.BP_jsonDoc,
    sDeviceName:=sDevName,
    io_fbFFHWO:=FFO,
    arrStates := aDbStateParams);

IF aDbStateParams[0].bBeamParamsLoaded and aDbStateParams[1].bBeamParamsLoaded THEN
    ffUpperCoating.i_Desc := CONCAT(sUpperCoatingType, sFFBeamParamMismatch);
    ffLowerCoating.i_Desc := CONCAT(sLowerCoatingType, sFFBeamParamMismatch);

    nUpperCoatingBitmask := aDbStateParams[0].stBeamParams.neVRange;
    nLowerCoatingBitMask := aDbStateParams[1].stBeamParams.neVRange;

    IF nCurrentEncoderCount <= nLowerCoatingBoundary THEN
        ffLowerCoating.i_xOK := (neVRange AND nLowerCoatingBitMask) = neVRange;
        ffUpperCoating.i_xOK  := TRUE;
    ELSIF nCurrentEncoderCount >= nUpperCoatingBoundary THEN
         ffUpperCoating.i_xOK := (neVRange AND nUpperCoatingBitmask) = neVRange;
        ffLowerCoating.i_xOK := TRUE;
    ELSE
        ffLowerCoating.i_xOK := FALSE;
        ffUpperCoating.i_xOK := FALSE;
    END_IF
ELSE
        ffUpperCoating.i_Desc := CONCAT(sUpperCoatingType, sFFBeamParamNotLoaded);
        ffLowerCoating.i_Desc := CONCAT(sLowerCoatingType, sFFBeamParamNotLoaded);
        ffUpperCoating.i_xOK := FALSE;
        ffLowerCoating.i_xOK := FALSE;

END_IF

ffUpperCoating(io_fbFFHWO:=FFO, i_xAutoReset := bAutoClear);
ffLowerCoating(io_fbFFHWO:=FFO, i_xAutoReset := bAutoClear);

bExecute := FALSE;]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>